/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <arpa/inet.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/in.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  //memset
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#include "communicate.h"

#define BUFLEN 512
#define MAXSTRING 120

void die(char *s) {
    perror(s);
    exit(1);
}

// This function returns host name for local computer
void check_host_name(int hostname) {
    if (hostname == -1) {
        perror("gethostname");
        exit(1);
    }
}

// find host info from host name
void check_host_entry(struct hostent *hostentry) {
    if (hostentry == NULL) {
        perror("gethostbyname");
        exit(1);
    }
}

// convert IP string to dotted decimal format
void IP_formatter(char *IPbuffer) {
    if (NULL == IPbuffer) {
        perror("inet_ntoa");
        exit(1);
    }
}

char *get_current_ip() {
    char client[256];
    char *client_IP;
    struct hostent *host_entry;
    int hostname;

    hostname = gethostname(client, sizeof(client));  // find the host name
    check_host_name(hostname);
    host_entry = gethostbyname(client);  // find host information
    check_host_entry(host_entry);

    client_IP = inet_ntoa(
        *((struct in_addr *)
              host_entry->h_addr_list[0]));  // Convert into client_IP string

    return client_IP;
}

void *startUPServer(void *a) {
    int *s;
    int recv_len;
    struct sockaddr_in si_other;
    char buf[BUFLEN];
    socklen_t slen = sizeof(si_other);
    s = (int *)a;

    while (1) {
        printf("UDP Server Up!\n");
        fflush(stdout);

        // try to receive some data, this is a blocking call
        if ((recv_len = recvfrom(*s, buf, BUFLEN, 0,
                                 (struct sockaddr *)&si_other, &slen)) == -1) {
            die("recvfrom()");
        }

        // print details of the client/peer and the data received
        printf("Received packet from %s:%d\n", inet_ntoa(si_other.sin_addr),
               ntohs(si_other.sin_port));
        printf("Data: %s\n", buf);

        // now reply the client with the same data
        if (sendto(*s, buf, recv_len, 0, (struct sockaddr *)&si_other, slen) ==
            -1) {
            die("sendto()");
        }
    }

    close(*s);
}

void communicate_prog_1(char *host) {
    CLIENT *clnt;
    bool_t *result_join;
    bool_t *result_leave;
    bool_t *result_subscirbe;
    bool_t *result_4;
    char *unsubscribe_1_IP;
    int unsubscribe_1_Port;
    char *unsubscribe_1_Article;
    bool_t *result_publish;
    char *publish_1_Article;
    char *publish_1_IP;
    int publish_1_Port;
    bool_t *result_6;

    char *client_IP = get_current_ip();

    printf("Client IP: %s\n", client_IP);

    // Create UDP socket --------
    unsigned int UDP_Port;
    struct sockaddr_in si_me, si_other;

    int s, i;

    // create a UDP socket
    if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {
        die("socket");
    }

    // zero out the structure
    memset((char *)&si_me, 0, sizeof(si_me));

    si_me.sin_family = AF_INET;
    si_me.sin_port = htons(0);
    si_me.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(s, (struct sockaddr *)&si_me, sizeof(si_me)) == -1) {
        die("bind");
    }

    struct sockaddr_in my_addr;
    bzero(&my_addr, sizeof(my_addr));
    socklen_t len = sizeof(my_addr);
    getsockname(s, (struct sockaddr *)&my_addr, &len);
    UDP_Port = ntohs(my_addr.sin_port);

    printf("UDP Port : %u\n", UDP_Port);
    //-----

    pthread_t t;

    int rc;

    rc = pthread_create(&t, NULL, startUPServer, (void *)&s);

    char ch;
    while (1) {
        // TODO: Add menu, and formatting
        printf("> ");
        ch = getchar();
        getchar();
        if (ch == 'q' || ch == EOF) {
            break;
        }

        clnt = clnt_create(host, COMMUNICATE_PROG, COMMUNICATE_VERSION, "udp");
        if (clnt == NULL) {
            clnt_pcreateerror(host);
            exit(1);
        }

        switch (ch) {
            case '1':
                result_join = join_1(client_IP, UDP_Port, clnt);

                // FIXME: better handler when server is down
                if (result_join == (bool_t *)NULL) {
                    clnt_perror(clnt, "call failed");
                }

                if (*result_join)
                    printf("Join Successfully\n");
                else
                    printf("Join Failed\n");

                break;
            case '2':
                result_leave = leave_1(client_IP, UDP_Port, clnt);

                // FIXME: better handler when server is down
                if (result_leave == (bool_t *)NULL) {
                    clnt_perror(clnt, "call failed");
                }

                if (*result_leave)
                    printf("Leave Successfully\n");
                else
                    printf("Leave Failed\n");
                break;
            case '3':
                char subscribe_topic[12];

                printf("Please input the type you wand to subscirbe:\n> ");
                scanf("%s", subscribe_topic);

                printf("Subscribe topic: %s\n", subscribe_topic);
                result_subscirbe = subscribe_1(client_IP, UDP_Port, subscribe_topic, clnt);

                // FIXME: better handler when server is down
                if (result_leave == (bool_t *)NULL) {
                    clnt_perror(clnt, "call failed");
                }
                // FIXME: Add message for subscribe fail or client not found?
                if (*result_subscirbe)
                    printf("Subscribe Successfully\n");
                else
                    printf("Subscribe Failed\n");

                break;
            case '4':
                // result_4 = unsubscribe_1(unsubscribe_1_IP,
                // unsubscribe_1_Port, unsubscribe_1_Article, clnt); if
                // (result_4 == (bool_t *) NULL) { 	clnt_perror (clnt, "call
                // failed"); } break;
            case '5':
                char publish_content[MAXSTRING];

                printf("Please input the content you wand to publish:\n> ");
                scanf("%s", publish_content);

                printf("Publish Content: %s\n", publish_content);
                result_publish = publish_1(publish_content, client_IP, UDP_Port, clnt);

                // FIXME: better handler when server is down
                if (result_publish == (bool_t *) NULL) {
                	clnt_perror (clnt, "call failed");
                }

                break;
            case '6':
                result_6 = ping_1(clnt);
                if (result_6 == (bool_t *)NULL) {
                    // clnt_perror (clnt, "call failed");
                    printf("Server is down\n");

                } else {
                    printf("Server is up\n");
                }
                break;

            default:
                printf("Invalid option\n");
                break;
        }
    }

    // kill UDP server thread
    pthread_cancel(t);

#ifndef DEBUG
    clnt_destroy(clnt);
#endif /* DEBUG */
}

int main(int argc, char *argv[]) {
    char *host;

    if (argc < 2) {
        printf("usage: %s server_host\n", argv[0]);
        exit(1);
    }
    host = argv[1];
    communicate_prog_1(host);
    exit(0);
}
