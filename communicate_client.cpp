/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <arpa/inet.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  //memset
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#include "communicate.h"
#include "ticket_lock.h"

#define BUFLEN 512
#define MAXSTRING 120

ticket_lock_t lock = TICKET_LOCK_INITIALIZER;

void die(char *s) {
    perror(s);
    exit(1);
}

// This function returns host name for local computer
void check_host_name(int hostname) {
    if (hostname == -1) {
        perror("gethostname");
        exit(1);
    }
}

// find host info from host name
void check_host_entry(struct hostent *hostentry) {
    if (hostentry == NULL) {
        perror("gethostbyname");
        exit(1);
    }
}

// convert IP string to dotted decimal format
void IP_formatter(char *IPbuffer) {
    if (NULL == IPbuffer) {
        perror("inet_ntoa");
        exit(1);
    }
}

char *get_current_ip() {
    char client[256];
    char *client_IP;
    struct hostent *host_entry;
    int hostname;

    hostname = gethostname(client, sizeof(client));  // find the host name
    check_host_name(hostname);
    host_entry = gethostbyname(client);  // find host information
    check_host_entry(host_entry);

    client_IP = inet_ntoa(
        *((struct in_addr *)
              host_entry->h_addr_list[0]));  // Convert into client_IP string

    return client_IP;
}

void *startUPServer(void *a) {
    int *s;
    int recv_len;
    struct sockaddr_in si_other;
    char buf[BUFLEN];
    socklen_t slen = sizeof(si_other);
    s = (int *)a;

    while (1) {
        // clean the buffer
        memset(buf, '\0', BUFLEN);
        // try to receive some data, this is a blocking call
        if ((recv_len = recvfrom(*s, buf, BUFLEN, 0,
                                 (struct sockaddr *)&si_other, &slen)) == -1) {
            die((char *)"recvfrom()");
        }

        ticket_lock(&lock);
        printf("\n\nReceived packet from host:\n");
        printf("---------------------\n");
        printf("%s\n", buf);
        printf("---------------------\n");
        ticket_unlock(&lock);
    }

    close(*s);
}

void print_menu() {
    printf("\nMenu: \n");
    printf("\t1. Join\n");
    printf("\t2. Leave\n");
    printf("\t3. Subscribe\n");
    printf("\t4. Unsubscribe\n");
    printf("\t5. Publish\n");
    printf("\t6. Ping\n");
    printf("\tq. Quit\n");
    printf("> ");
}

char *client_IP;
unsigned int UDP_Port;
CLIENT *clnt;

void communicate_prog_1(char *host) {
    bool_t *result_join;
    bool_t *result_leave;
    bool_t *result_subscirbe;
    bool_t *result_unsubscirbe;
    char *unsubscribe_1_Article;
    bool_t *result_publish;
    char *publish_1_Article;
    bool_t *result_ping;

    // if (pthread_mutex_init(&lock, NULL) != 0) {
    //     printf("\n mutex init has failed\n");
    //     return;
    // }

    client_IP = get_current_ip();

    printf("Client IP: %s\n", client_IP);

    // Create UDP socket --------
    struct sockaddr_in si_me, si_other;

    int s, i;

    // create a UDP socket
    if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {
        die((char *)"socket");
    }

    printf("UDP Server Up!\n");
    fflush(stdout);

    // zero out the structure
    memset((char *)&si_me, 0, sizeof(si_me));

    si_me.sin_family = AF_INET;
    si_me.sin_port = htons(0);
    si_me.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(s, (struct sockaddr *)&si_me, sizeof(si_me)) == -1) {
        die((char *)"bind");
    }

    struct sockaddr_in my_addr;
    bzero(&my_addr, sizeof(my_addr));
    socklen_t len = sizeof(my_addr);
    getsockname(s, (struct sockaddr *)&my_addr, &len);
    UDP_Port = ntohs(my_addr.sin_port);

    printf("UDP Port : %u\n", UDP_Port);
    //-----

    pthread_t t;

    int rc = pthread_create(&t, NULL, startUPServer, (void *)&s);

    char ch, tmp_ch;
    while (1) {
        ticket_lock(&lock);

        print_menu();
        ch = getchar();
        while (ch == '\n') {
            print_menu();
            ch = getchar();
        }
        tmp_ch = getchar();

        if (ch == 'q' || ch == EOF) {
            leave_1(client_IP, UDP_Port, clnt);
            break;
        }

        clnt = clnt_create(host, COMMUNICATE_PROG, COMMUNICATE_VERSION, "udp");
        if (clnt == NULL) {
            clnt_pcreateerror(host);
            exit(1);
        }

        switch (ch) {
            case '1':
                result_join = join_1(client_IP, UDP_Port, clnt);

                if (result_join == (bool_t *)NULL) {
                    // clnt_perror(clnt, "call failed");
                    printf("Server is down\n");
                    break;
                }

                if (*result_join)
                    printf("Join Successfully\n");
                else
                    printf("Join Failed\n");

                break;
            case '2':
                result_leave = leave_1(client_IP, UDP_Port, clnt);

                if (result_leave == (bool_t *)NULL) {
                    // clnt_perror(clnt, "call failed");
                    printf("Server is down\n");
                    break;
                }

                if (*result_leave)
                    printf("Leave Successfully\n");
                else
                    printf("Leave Failed\n");
                break;
            case '3':
                char subscribe_topic[12];

                printf("Please input the type you wand to subscirbe:\n\t> ");
                fgets(subscribe_topic, MAXSTRING, stdin);

                if ((strlen(subscribe_topic) > 0) &&
                    (subscribe_topic[strlen(subscribe_topic) - 1] == '\n'))
                    subscribe_topic[strlen(subscribe_topic) - 1] = '\0';

                result_subscirbe =
                    subscribe_1(client_IP, UDP_Port, subscribe_topic, clnt);

                if (result_subscirbe == (bool_t *)NULL) {
                    // clnt_perror(clnt, "call failed");
                    printf("Server is down\n");
                    break;
                }

                // FIXME: Add message for subscribe fail or client not found?
                if (*result_subscirbe) {
                    printf("Subscribe Successfully\n");
                    while (((ch = getchar()) != '\n') && (ch != EOF))
                        ;
                } else {
                    printf("Subscribe Failed\n");
                    while (((ch = getchar()) != '\n') && (ch != EOF))
                        ;
                }

                break;
            case '4':
                char unsubscribe_topic[12];

                printf("Please input the type you wand to unsubscirbe:\n\t> ");
                // scanf("%s", unsubscribe_topic);
                if ((strlen(unsubscribe_topic) > 0) &&
                    (unsubscribe_topic[strlen(unsubscribe_topic) - 1] == '\n'))
                    unsubscribe_topic[strlen(unsubscribe_topic) - 1] = '\0';
                // tmp_ch = getchar();

                printf("Unsubscribe topic: %s\n", unsubscribe_topic);

                result_unsubscirbe =
                    unsubscribe_1(client_IP, UDP_Port, unsubscribe_topic, clnt);

                if (result_unsubscirbe == (bool_t *)NULL) {
                    // clnt_perror(clnt, "call failed");
                    printf("server is down\n");
                    break;
                }

                // FIXME: Add message for subscribe fail or client not found?
                if (*result_unsubscirbe) {
                    printf("Unsubscribe Successfully\n");
                    while (((ch = getchar()) != '\n') && (ch != EOF))
                        ;
                } else {
                    printf("Unsubscribe Failed\n");
                    while (((ch = getchar()) != '\n') && (ch != EOF))
                        ;
                }

                break;
            case '5':
                char publish_content[MAXSTRING];

                printf("Please input the content you wand to publish:\n\t> ");
                // scanf("%s", publish_content);
                fgets(publish_content, MAXSTRING, stdin);

                if ((strlen(publish_content) > 0) &&
                    (publish_content[strlen(publish_content) - 1] == '\n'))
                    publish_content[strlen(publish_content) - 1] = '\0';

                printf("Publish Content: %s\n", publish_content);
                result_publish =
                    publish_1(publish_content, client_IP, UDP_Port, clnt);

                if (result_publish == (bool_t *)NULL) {
                    // clnt_perror(clnt, "call failed");
                    printf("Server is down\n");
                    break;
                }

                if (*result_publish) {
                    printf("Publish Successfully\n");
                } else {
                    printf("Publish Failed\n");
                }

                break;
            case '6':
                result_ping = ping_1(clnt);

                if (result_ping == (bool_t *)NULL)
                    printf("Server is down\n");
                else
                    printf("Server is up\n");

                break;

            default:
                printf("Invalid option\n");

                if (tmp_ch != '\n')
                    while (((ch = getchar()) != '\n') && (ch != EOF))
                        ;

                break;
        }
        ticket_unlock(&lock);
    }

    // kill UDP server thread
    pthread_cancel(t);

#ifndef DEBUG
    clnt_destroy(clnt);
#endif /* DEBUG */
}

void intHandler(int dummy) {
    printf("Interrupted\n");
    leave_1(client_IP, UDP_Port, clnt);
    exit(0);
}

int main(int argc, char *argv[]) {
    char *host;

    if (argc < 2) {
        printf("usage: %s server_host\n", argv[0]);
        exit(1);
    }
    host = argv[1];

    signal(SIGINT, intHandler);

    communicate_prog_1(host);
    exit(0);
}
